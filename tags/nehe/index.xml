<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Nehe on Chinese</title><link>https://yaoyl.cn/tags/nehe/</link><description>Recent content in Nehe on Chinese</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>Copyright © 2017–2025, Yunyao Long and the Hugo Authors; 粤ICP备-17050867-1号</copyright><lastBuildDate>Sat, 13 May 2017 16:49:22 +0000</lastBuildDate><atom:link href="https://yaoyl.cn/tags/nehe/index.xml" rel="self" type="application/rss+xml"/><item><title>OpenGL学习笔记（十）</title><link>https://yaoyl.cn/post/%E5%8E%86%E5%8F%B2/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8D%81/</link><pubDate>Sat, 13 May 2017 16:49:22 +0000</pubDate><guid>https://yaoyl.cn/post/%E5%8E%86%E5%8F%B2/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8D%81/</guid><description>
&lt;p&gt;&lt;strong&gt;龙云尧个人博客，转载请注明出处。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CSDN地址：http://blog.csdn.net/michael753951/article/details/72810534&lt;/p&gt;
&lt;p&gt;个人blog地址：http://yaoyl.cn/nehexue-xi-bi-ji-shi/&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id="概述"&gt;概述&lt;/h1&gt;
&lt;p&gt;本部分博客将以nehe教程第2课，笔记（三）为蓝本，将Windows中完成的基础实验在Ubuntu中进行实现。&lt;/p&gt;
&lt;p&gt;在&lt;a href="http://yaoyl.cn/ubuntu-huan-jing-pei-zhi/"&gt;【Ubuntu环境配置】&lt;/a&gt;中我们已经对Ubuntu中的OpenGL环境进行了配置，并且完成了最基础的茶壶demo，接下来我们将进行实验相关的后续开发。&lt;/p&gt;
&lt;h1 id="需求分析"&gt;需求分析&lt;/h1&gt;
&lt;p&gt;因为实验中我们需要终端接收到的数据能够在图形界面中实时显示出来，这里我们使用nehe教程的第二课内容，绘制一个矩形作为进度条，起始为0%，最高为100%。接着我们将让这个进度条能够对传输过来的信号产生反馈。将整个过程进行拆分，我们可以按照如下步骤进行实现。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构建一个OpenGL窗口，能够根据本地按键实现进度条控制&lt;/li&gt;
&lt;li&gt;让OpenGL的窗口能够接收其他终端发送过来的消息&lt;/li&gt;
&lt;li&gt;让OpenGL窗口对接收到的信息进行一定的实时反馈（比如进度条变换）&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="实验"&gt;实验&lt;/h1&gt;
&lt;h2 id="opengl窗口搭建"&gt;OpenGL窗口搭建&lt;/h2&gt;
&lt;p&gt;本次使用的代码是以nehe教程第二课中，Linux代码为蓝本，进行修改实现的。&lt;a href="http://nehe.gamedev.net/data/lessons/linux/lesson02.tar.gz"&gt;【代码链接】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先我们将窗口显示中的三角形去掉，留下一个长方形，同时将长方形的右边两个点和左边两个点重合以做出进度条为0%的感觉。代码如下：&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
&lt;picture&gt;
&lt;img
loading="lazy"
decoding="async"
alt="进度条代码"
class="image_figure image_internal image_unprocessed"
src="https://yaoyl.cn/"
/&gt;
&lt;/picture&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id="按钮控制的实现"&gt;按钮控制的实现&lt;/h3&gt;
&lt;p&gt;我在初始化InitGL的时候，将square_len初始化为0，当有按键触发的时候，square_len++，这样就能够完成进度条的前进工作。&lt;/p&gt;
&lt;p&gt;在原始代码中，我们可以看到main函数中，有一个&lt;code&gt;glutKeyboardFunc&lt;/code&gt;方法，传入了&lt;code&gt;keyPressed&lt;/code&gt;的地址，在&lt;code&gt;keyPressed&lt;/code&gt;中，定义了使用&lt;code&gt;ESC&lt;/code&gt;按钮进行退出的方法。我们将在这里进行尝试，试试方向键左和方向键右能不能让窗口出现一些反馈。&lt;/p&gt;
&lt;p&gt;在经过不短的一段时间的寻找之后，我终于找到了在OpenGL中，各种按键的键值是在&lt;code&gt;glut.h&lt;/code&gt;中预定义好的。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
&lt;picture&gt;
&lt;img
loading="lazy"
decoding="async"
alt="键值"
class="image_figure image_internal image_unprocessed"
src="https://yaoyl.cn/"
/&gt;
&lt;/picture&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;参考一片CSDN博客&lt;a href="http://blog.csdn.net/andy20081251/article/details/38922295"&gt;【pengl键盘控制一】&lt;/a&gt;，我们可以发现在本次程序中，ESC按键确实也刚好是27，这是不是也就意味着我们可以直接按照上面的方法进行修改了？首先我们将ESC的宏定义值修改为102(十进制，对应0x66)，尝试使用左键退出窗体程序。&lt;/p&gt;
&lt;p&gt;但是很意外的，没有成功。是不是按键本身的键值并不是102？&lt;/p&gt;
&lt;p&gt;我对代码进行进一步修改，当有按键活动的时候，记录下来当前按键的键值，将其存进本地文件中。（亲测不能直接printf，因为根本不会显示出来，至于原因待会会有解释）代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 1&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt;/* The function called whenever a key is pressed. */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 2&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;keyPressed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 3&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="cm"&gt;/* avoid thrashing this procedure */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 4&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;//usleep(100);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 5&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 6&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;fopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;key_value.txt&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;a+&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// a+意味着在文本最后追加
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 7&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 8&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;fclose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 9&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;10&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="cm"&gt;/* If escape is pressed, kill everything. */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;11&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;ESCAPE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;12&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="cm"&gt;/* shut down our window */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;13&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glutDestroyWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;window&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;14&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;15&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="cm"&gt;/* exit the program...normal termination. */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;16&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;17&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;18&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;尝试按下F1~F12的按键，以及上下左右等按键，以及数字按键之后，我们发现txt文档中只记录下来了数字键值，根本没有其他的键值。&lt;/p&gt;</description></item><item><title>OpenGL学习笔记（九）</title><link>https://yaoyl.cn/post/%E5%8E%86%E5%8F%B2/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%9D/</link><pubDate>Fri, 12 May 2017 18:00:15 +0000</pubDate><guid>https://yaoyl.cn/post/%E5%8E%86%E5%8F%B2/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%9D/</guid><description>
&lt;p&gt;&lt;strong&gt;龙云尧个人博客，转载请注明出处。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CSDN地址：http://blog.csdn.net/michael753951/article/details/71750809&lt;/p&gt;
&lt;p&gt;个人blog地址：http://yaoyl.cn/nehexue-xi-bi-ji-jiu/&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id="前言"&gt;前言&lt;/h1&gt;
&lt;p&gt;本次笔记为nehe课程第11课的学习内容，通过实验，我们可以利用正弦函数绘制一个舞动的旗帜。在本次课程中，我们也将学习OpenGL中glPolygonMode函数对一个模型的正面和反面进行不同模式的绘图。&lt;/p&gt;
&lt;h2 id="glpolygonmode-函数介绍"&gt;glPolygonMode 函数介绍&lt;/h2&gt;
&lt;p&gt;本部分内容请先查看前人整理的博客&lt;a href="http://www.cnblogs.com/Clingingboy/archive/2010/10/18/1854255.html"&gt;【OpenGL学习笔记(7)多边形绘制】&lt;/a&gt;。请先仔细阅读该博客，理解如何区分模型中的正面反面（依然遵守右手定则，由描点的方向决定），以及3种填充方式（fill，line point）。&lt;/p&gt;
&lt;h1 id="代码分析"&gt;代码分析&lt;/h1&gt;
&lt;p&gt;好了，到这里新的基本知识就已经讲述完毕了，我们看看作者是如何实现一个舞动的旗帜的。（基本的代码我就不分析了，只挑重点）&lt;/p&gt;
&lt;p&gt;InitGL中，在设置完纹理和透视的init之后，我们将插入glPolygonMode方法进行正反不同方式填充（以此从直观上区分正反面）。然后完成45*45个点阵的绘制。&lt;/p&gt;
&lt;p&gt;绘制中，作者将45*45个点阵均匀分布到一个长为9个单位，宽为9个单位，并且中点放置在原点上的正方形中（通过-4.5将中点移动到原点）。Z轴上，作者绘制了一个以x为自变量的正弦函数（刚好一个周期，至于为什么需要一个周期，在看完本篇博客之后你将会有答案）。&lt;/p&gt;
&lt;p&gt;接下来DrawGLScene开始进行图像旋转。这里我注释掉了作者的沿y轴和z轴旋转，仅仅保留沿x轴旋转，以方便观察。模型绘制和纹理绑定部分我不分析了，已经是很经典的代码了，就是利用45*45个点阵绘制44*44个正方形而已。&lt;/p&gt;
&lt;p&gt;接下来就是本此实验的重点了。一个if判断，这个判断实现了旗帜的舞动。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 1&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;wiggle_count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 2&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 3&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;45&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 4&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 5&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;hold&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;points&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 6&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;44&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 7&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 8&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;points&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;points&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 9&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;10&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;points&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;44&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;hold&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;11&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;12&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;wiggle_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;13&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;仔细阅读代码我们可以发现，作者通过wiggle_count计数，每两帧画面，就将45*45点阵中的z值向左移动一位，最左边的z值放到最右边，实现循环。所以整个if实现的就是将一个正弦波向左移动，这也就是为什么我们在实验中旗帜的挥动，波纹向左走的原因。&lt;/p&gt;
&lt;p&gt;剩下的代码就不用怎么解释了，都是和以前一样的代码了。&lt;/p&gt;
&lt;p&gt;回到一开始的问题，为什么在设置45*45点阵的z值的时候，要使用2*pi将正弦波控制在一个周期。可不可以乘以n*pi，或者2*n*pi，或者其他值。（提示，if条件中左移的时候，左端点会被移动到右端，此时这个端点有可能是一个突变点造成波形尖锐或者畸形）。&lt;/p&gt;
&lt;p&gt;最后附上效果图，首先是作者源代码的运行结果。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
&lt;picture&gt;
&lt;img
loading="lazy"
decoding="async"
alt="section9.1"
class="image_figure image_internal image_unprocessed"
src="https://yaoyl.cn/"
/&gt;
&lt;/picture&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;然后是经过我注释掉y轴旋转，z轴旋转以及注释掉了整个if判断之后的图像。我们发现这个时候图像已经不能飘动了，而且上下两个边界呈现一种标准的正弦波的形式。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
&lt;picture&gt;
&lt;img
loading="lazy"
decoding="async"
alt="section9.2"
class="image_figure image_internal image_unprocessed"
src="https://yaoyl.cn/"
/&gt;
&lt;/picture&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后是没有注释if，单单注释掉y轴旋转和z轴旋转的图像。喜事已经能够正常的飘动了。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
&lt;picture&gt;
&lt;img
loading="lazy"
decoding="async"
alt="section9.3"
class="image_figure image_internal image_unprocessed"
src="https://yaoyl.cn/"
/&gt;
&lt;/picture&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h1 id="显示列表"&gt;显示列表&lt;/h1&gt;
&lt;p&gt;nehe教程第12课显示列表。&lt;/p&gt;
&lt;p&gt;该课程主要讲解了glGenLists的使用样例。在使用之前，我们可以了解一下使用glGenLists能给你程序性能所带来的好处。这部分只是我们可以参考&lt;a href="http://blog.csdn.net/dcrmg/article/details/53133112"&gt;【OpenGL（八） 显示列表】&lt;/a&gt;以及&lt;a href="http://www.cnblogs.com/yxnchinahlj/archive/2010/11/19/1881426.html"&gt;【OpenGL显示列表】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本次课程需要使用的光、材质和光照模型，就比较符合glGenLists的使用环境。&lt;/p&gt;
&lt;p&gt;我们来看看课程代码，作者首先定义了两个二位数组，boxcol用来存放立方体除了top之外，其他所有面的5种取，topcol用来存放立方体的顶部颜色。&lt;/p&gt;
&lt;p&gt;接下来作者定义了BuildLists方法，在这个方法中，作者使用了本次课程的核心——显示列表。使用方法大致如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先调用glGenListst生成一个显示列表（连续地址的数组形式），本次实验中作者生成了包含2个元素的数组，返回数组的首地址给box（不过定义的时候并没有定义成指针，有些奇怪）&lt;/li&gt;
&lt;li&gt;接着作者使用glNewList和glEndList定义显示列表中的每一个元素。
&lt;ul&gt;
&lt;li&gt;在GLNewList方法中，作者传入了box指向的第一个显示元素，同时传入了一个参数GL_COMPILE。（注意：按照【OpenGL显示列表】中所告诉我们的知识，glNewList的函数原型为&lt;code&gt;void glNewList(GLuint list,GLenum mode);&lt;/code&gt;说明一个显示列表的开始，其后的OpenGL函数存入显示列表中，直至调用结束表的函数（见下面）。参数list是一个正整数，它标志唯一的显示列表。参数mode的可能值有GL_COMPILE和GL_COMPILE_AND_EXECUTE。若要使后面的函数语句只存入而不执行，则用GL_COMPILE；若要使后面的函数语句存入表中且按瞬时方式执行一次，则用GL_COMPILE_AND_EXECUTE。）&lt;/li&gt;
&lt;li&gt;glNewList和glEndList中间定义矩阵的语句我这里就不再分析，和之前一样。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定义完显示列表中第一个元素之后，定义第二个元素时，需要将数组头指针向后移一位，所以代码中会有&lt;code&gt;top=box+1;&lt;/code&gt;一行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接着本次实验中作者修改了InitGL方法，他在Init的最后几行中，调用了3个glEnable方法，打开了GPU默认的灯光(GL_LIGHT0)，自定义的灯光(GL_LIGHTING)，以及颜色纹理(GL_COLOR_MATERIAL)，注意，如果不激活颜色纹理的话，在我们DrawGLScene中，将只能够贴上图片纹理，但是无法再往上添加颜色纹理（即之后的glColor3fv失效）。&lt;/p&gt;</description></item><item><title>OpenGL学习笔记（八）</title><link>https://yaoyl.cn/post/%E5%8E%86%E5%8F%B2/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB/</link><pubDate>Fri, 12 May 2017 03:28:48 +0000</pubDate><guid>https://yaoyl.cn/post/%E5%8E%86%E5%8F%B2/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB/</guid><description>
&lt;p&gt;&lt;strong&gt;龙云尧个人博客，转载请注明出处。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CSDN地址：http://blog.csdn.net/michael753951/article/details/71702311&lt;/p&gt;
&lt;p&gt;个人blog地址：http://yaoyl.cn/nehexue-xi-bi-ji-ba/&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;p&gt;本部分单独讲Lesson10的内容，本次讲述重点将不再是作者在代码中各种方法如何如何调用，比如如何实现旋转，如何绘制图像，如何实现透明，如何实现步进等等，这个在我前面7篇笔记中已经有详细的说明了，本篇笔记将不再重复，如果有什么疑问可以翻我之前的笔记或者上网查询。&lt;/p&gt;
&lt;p&gt;本次实验参变量不少，作者通过代码带我们真正的实现了一个3D世界，我们可以在这个3D世界里面自由的走动和观察。（也是我们玩的譬如《我的世界》这样的第一视角游戏的世界构建的基本）&lt;/p&gt;
&lt;p&gt;文中给出了几个数据结构——tagVERTEX，tagTRIANGLE，tagSECTOR。vertex用来存放每一个坐标点的空间直角坐标系中的位置（x, y, z）和需要展示的图像的位置（u, v），trandgle表示三角形中存在的3个点，包含3个tagVERTEX（事实上，现今大多数人都是用无数这样的三角形来近似/逼近一个曲面），然后sector表示一个由许多三角形构成的体的结构。文中，所有的与体相关的三角形都放在一个文件中，通过读写文件来对体进行操作。&lt;/p&gt;
&lt;h2 id="代码分析"&gt;代码分析&lt;/h2&gt;
&lt;p&gt;好了，大致的介绍已经完成，我们接着看看作者是如何一步一步完成这个3D世界的建设的。（晚上课程中已经解释的地方我这里不再重复，而还未解释清楚的地方我将重点解释）&lt;/p&gt;
&lt;p&gt;作者首先定义了一个readstr方法，用来读取文件f中的内容，将其读进string指向的内存空间。接着定义了一个SetupWorld方法，将&amp;quot;data/world.txt&amp;quot;中的内容调用readstr方法读取内容，并将其写进 tagSECTOR 类的变量 sector1 中，关于txt中数据格式需要在这里说明一下——每一行代表一个坐标点的信息，包含5个变量，分别为该点的x轴坐标、y轴坐标、z轴坐标、该点对应的渲染图片的点的x坐标，该点对应的渲染图片的点的y坐标。每3行（即3个点）构成一个3角形。前3个变量各位可能还有印象，后两个点可以回去看看《nehe学习笔记（五）》，找找&lt;code&gt;glTexCoord2f&lt;/code&gt;方法的说明。&lt;/p&gt;
&lt;p&gt;然后是和以前一样的LoadBMP以及LoadGLTextures方法。InitGL方法中，打开纹理映射和深度测试，同时调用之前定义好的SetupWorld方法读入所有三角形的信息。&lt;/p&gt;
&lt;p&gt;接下来就是第一个重头戏DrawGLScene了，所有的动作都是在这里展示出来的，理解这一块的知识对我们将来自己构建3D世界有莫大的帮助。&lt;/p&gt;
&lt;p&gt;该部分首先定义了5个浮点数x_m, y_m, z_m, u_m, v_m，分别用来对应tagVERTEX中的5个5种元素。使用xtrans &amp;amp; ytrans &amp;amp; ztrans 分别表示画笔起笔处的x坐标 &amp;amp; y坐标 &amp;amp; z坐标（也就是说在glTranslatef中将被用到。），接着定义了xtrans &amp;amp; ztrans &amp;amp; ytrans，这三个值决定了画笔起点沿X轴、Y轴、Z轴移动的长度，也即决定了画笔的起点位置（也即整张地图的位置），sceneroty则据定了角色的视觉角度。&lt;/p&gt;
&lt;p&gt;变量中我们需要注意，本次实验中，沿着某轴移动的长度通常以 pos 结尾作为变量，而旋转的角度通常以 ros 结尾作为变量，谨记这一点对我们后期按键控制的理解会有帮助。&lt;/p&gt;
&lt;p&gt;接着作者调用两次glRotatef，先将图像沿着x轴旋转一定角度(lookupdown)，完成抬头动作，再将图像沿着y轴旋转一定角度(sceneroty)，完成正面朝向的转换。&lt;/p&gt;
&lt;p&gt;现在我们已经确定了抬头角度和视角，接下来就要设定你现在所处的位置了——其实就是反方向移动整个3D模型即可，这也就是为什么在trans赋值的时候，会取负数的原因。&lt;/p&gt;
&lt;p&gt;在上一步骤调用glTranslatef已经绘点结束之后，我们将开始进行图像绘制，这个部分就不细说了。我对文本中前3行（第一个三角形）标稍作图解，剩下的你可以自己尝试继续绘制。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
&lt;picture&gt;
&lt;img
loading="lazy"
decoding="async"
alt="坐标系"
class="image_figure image_internal image_unprocessed"
src="https://yaoyl.cn/"
/&gt;
&lt;/picture&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;到这一步，绘制完成，接下来的KillGLWindow以及CreateGLWindow以及WndProc和之前一致，不解释。&lt;/p&gt;
&lt;p&gt;第二个重头戏来了，WinMain。这个部分我们将实现通过按键控制你在整个3D世界中的游荡（其实是在控制整个3D世界移动）。下面我将仔细解释。&lt;/p&gt;
&lt;p&gt;B键设置透明，这个之前笔记解释过，&lt;strong&gt;记得disable深度测试，然后enable透明&lt;/strong&gt;。F键设置画质，不解释了。&lt;/p&gt;
&lt;p&gt;接下来是按up键，这个时候首先会更改xpos和zpos，为什么会如此修改，期初我也很疑惑，不过在画了一张图解之后，便豁然开朗了。我们根据代码可以知道heading这个变量代表了你当前正脸朝向与Z轴正向的角度（因为heading赋值给了yrot，而yrot是绕着y轴旋转的角度，所以heading就是你转身的角度啦）。&lt;/p&gt;
&lt;p&gt;通过下图我们便可以知道为什么使用UP键向前走的时候，作者使用如下两行代码实现移动了。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
&lt;picture&gt;
&lt;img
loading="lazy"
decoding="async"
alt="up&amp;amp;amp;amp;down"
class="image_figure image_internal image_unprocessed"
src="https://yaoyl.cn/"
/&gt;
&lt;/picture&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;1&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;xpos&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heading&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;piover180&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;0.05f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;2&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;zpos&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heading&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;piover180&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;0.05f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接着作者在pos变换完成以后，稍稍微修改walkbias变量，它将影响到ypos，从而模仿人行走的时候的高低起伏，让人更加自然。&lt;/p&gt;
&lt;p&gt;接下来的 left, right, page_up &amp;amp; page_down 按键的反馈设置就基本不用解释啦，你按照右手定则稍稍为跟着做一下就能够理解啦。需要注意的是，在WinMain中，所有的pos和trans都是从观察者的角度进行变换的，真正的变换是在DrawGLScene，在DrawGLScene方法中我们已经对数据做了特殊处理以保证显示正常自然。&lt;/p&gt;
&lt;p&gt;好了，到这里本章节的代码也就解释完毕了，粗读代码会觉得很容易，因为都是我们之前已经掌握的内容，但是细想作者是如何一步一步具体实现的时候，情况就会复杂很多。通过不断画图和翻以前的代码，我才不断的深入理解整个OpenGL的原理，以及3D模型的构建原理和过程。至此，OpenGL应该算是正式入门了吧。&lt;/p&gt;
&lt;p&gt;稍稍留一个小问题，你知道为什么作者在DrawGLScene方法中，xtrans直接赋值为xpos的负值，ztrans同样直接赋值为zpos的负值，sceneroty也是直接取了yrot的负值（不过为了严谨，又添了一个360作为进位），偏偏ytrans要在赋值为walkbias的负值之后，还要减去一个0.25呢？（提示，walkbias乘上sin之后有正有负，如果不添加一个常数，你的“眼睛”就会在地板所在的y=0面上不断上下抖动，而添加0.25之后，则是将你的“眼睛”提高到了一定的高度，让你有了身高的感觉，从而更加自然）&lt;/p&gt;</description></item><item><title>OpenGL学习笔记（七）</title><link>https://yaoyl.cn/post/%E5%8E%86%E5%8F%B2/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83/</link><pubDate>Tue, 09 May 2017 20:59:35 +0000</pubDate><guid>https://yaoyl.cn/post/%E5%8E%86%E5%8F%B2/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83/</guid><description>
&lt;p&gt;龙云尧个人博客，转载请注明出处。&lt;/p&gt;
&lt;p&gt;CSDN地址：http://blog.csdn.net/michael753951/article/details/71511785&lt;/p&gt;
&lt;p&gt;个人blog地址：http://yaoyl.cn/nehexue-xi-bi-ji-qi-2017-05-09-20-59/&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我们在前六个部分已经尝试了nehe教程中1-8可得所有内容，接下来第七部分将实现一个简单的实验，这个实验将涵盖前面所有的内容，以作为一个前期总结。&lt;/p&gt;
&lt;h2 id="前期准备"&gt;前期准备&lt;/h2&gt;
&lt;p&gt;在实验之前，我们需要知道一个OpenGL中的基本概念。OpenGL中glEnable方法的使用。关于这个功能函数的使用以及参数设定，你可以点击&lt;a href="http://blog.csdn.net/liguangzhenghi/article/details/8166350"&gt;【gl.glenable()介绍】&lt;/a&gt;以及&lt;a href="http://blog.csdn.net/huutu/article/details/20872525"&gt;【glEnable(GL_DEPTH_TEST) 有什么用？】&lt;/a&gt;进行查看。以下关于glenable的内容转载自上述第二篇博客。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在InitGL() 或者类似的初始化OpenGL的地方，会有glEnable(GL_DEPTH_TEST);&lt;/p&gt;
&lt;p&gt;启用了之后，OpenGL在绘制的时候就会检查，当前像素前面是否有别的像素，如果别的像素挡道了它，那它就不会绘制，也就是说，OpenGL就只绘制最前面的一层。&lt;/p&gt;
&lt;p&gt;当我们需要绘制透明图片时，就需要关闭它
glDisable(GL_DEPTH_TEST);
并且打开混合
glEnable(GL_BLEND);&lt;/p&gt;
&lt;p&gt;而且还需要设置使用的透明度
glColor4f(1.0f,1.0f,1.0f,0.5f);
这样就是一半的显示了，设置为1就是不透明&lt;/p&gt;
&lt;p&gt;glBlendFunc(GL_SRC_ALPHA,GL_ONE);
基于源像素Alpha通道值的半透明混合函数&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在实验一以及后续的几个实验中，我们Enable的都是传入GL_DEPTH_TEST作为参数启用深度测试。并立刻在glEnable方法后面调用glDepthFunc(GL_LEQUAL);方法进行前景像素的显示设置。&lt;/p&gt;
&lt;p&gt;这个概念在之前的实验中有所涉及，但是我们当时没有关注，这里我们将将其单独拿出来进行分析。**本部分以下部分均为转载。**转载来源为&lt;a href="http://blog.csdn.net/u012463389/article/details/50748128"&gt;【glDepthFunc】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void glDepthFunc(GLenum func);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数功能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;指定“目标像素与当前像素在z方向上值大小比较”的函数，符合该函数关系的目标像素才进行绘制，否则对目标像素不予绘制。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func指定深度比较函数，GL_NEVER,GL_LESS,GL_EQUAL,GL_LEQUAL,GL_GREATER,GL_NOTE_QUAL,GL_GEQUAL,GL_ALWAYS,缺省值GL_LESS，
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;GL_NEVER,不通过（输入的深度值不取代参考值）&lt;/p&gt;
&lt;p&gt;GL_LESS,如果输入的深度值小于参考值，则通过&lt;/p&gt;
&lt;p&gt;GL_EQUAL,如果输入的深度值等于参考值，则通过&lt;/p&gt;
&lt;p&gt;GL_LEQUAL,如果输入的深度值小于或等于参考值，则通过&lt;/p&gt;
&lt;p&gt;GL_GREATER,如果输入的深度值大于参考值，则通过&lt;/p&gt;
&lt;p&gt;GL_NOTE_QUAL,如果输入的深度值不等于参考值，则通过&lt;/p&gt;
&lt;p&gt;GL_GEQUAL,如果输入的深度值大于或等于参考值，则通过&lt;/p&gt;
&lt;p&gt;GL_ALWAYS,总是通过（输入的深度值取代参考值）&lt;/p&gt;
&lt;p&gt;描述：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 通过目标像素与当前像素在z方向上值大小的比较是否满足参数指定的条件，来决定在深度（z方向）上是否绘制该目标像素。该函数只有启用“深度测试”时才有效，参考glEnable(GL_DEPTH_TEST)和glDisable(GL_DEPTH_TEST)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="代码分析"&gt;代码分析&lt;/h2&gt;
&lt;p&gt;前期准备能够帮助我们更好的理解作者在代码中的方法调用，，也能帮助我们更加深入的了解OpenGL的运行机制。我们接下来探讨本次实验中的实现方式。&lt;/p&gt;
&lt;p&gt;根据Lesson1课程给我们大基建好的框架结构以及我们整理出来的那张结构图，我们可以快速理解本次实验代码。&lt;/p&gt;
&lt;p&gt;首先定义了一个stars结构体，用来存放每一个星星的RGB值，与中心点的距离以及选装角度。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;1&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="c1"&gt;// Create A Structure For Star
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;2&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;3&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Stars Color
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;4&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;GLfloat&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Stars Distance From Center
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;5&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;angle&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Stars Current Angle
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;6&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;7&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;stars&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;8&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;stars&lt;/span&gt; &lt;span class="n"&gt;star&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// Need To Keep Track Of &amp;#39;num&amp;#39; Stars
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接着是LoadBMP和LoadGLTextures，这个和以前的实验代码无异，只需要改一下读入的文件名即可。ReSizeGLScene函数同样不需要修改。&lt;/p&gt;</description></item><item><title>OpenGL学习笔记（六）</title><link>https://yaoyl.cn/post/%E5%8E%86%E5%8F%B2/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/</link><pubDate>Mon, 08 May 2017 13:54:19 +0000</pubDate><guid>https://yaoyl.cn/post/%E5%8E%86%E5%8F%B2/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/</guid><description>
&lt;p&gt;&lt;strong&gt;龙云尧个人博客，转载请注明出处。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CSDN地址：http://blog.csdn.net/michael753951/article/details/71407260&lt;/p&gt;
&lt;p&gt;个人blog地址：http://yaoyl.cn/nehexue-xi-bi-ji-liu-2017-05-08-13-54/&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id="混合"&gt;混合&lt;/h1&gt;
&lt;p&gt;我们在很多场合都过这样的经历，在设置某些色块的颜色的时候，我们不光要设置它的RGB值，还可能需要设置它的Alpha值。一般理解上，我们都认为这个Alpha值代表了当前色块的透明度。这样只是最外在的理解，其实图像的透明是一个颜色的混合过程，当有两种颜色混叠的时候，这个Alpha是用来控制两种颜色的混色程度的一种值。&lt;/p&gt;
&lt;p&gt;颜色的混合公式为(Rs*As + Rd (1 - As), Gs*As + Gd (1 - As), Bs*As + Bs (1 - As), As*As + Ad (1 - As))。其中As表示前景色的Alpha值，Rs表示前景色的R值，Rd表示背景色的R值，Gs &amp;amp; Gd，Bs &amp;amp; Bd类似。最终计算出来的RGB值就是混合之后显示出来的RGB值。&lt;/p&gt;
&lt;p&gt;举个例子，我们已经知道背景色是（255,255,255），现在有一个（128,128,128）的色块需要层叠在背景色块之上，并且我们先假设Alpha值为1.0，那我们很容易计算出来最终的显示的RGB值为（128,128,128），这个时候我们就从直观上认为前景色完全不透明。而如果Alpha为0.0，计算结果显然为（255,255,255），这个时候我们就认为前景色完全透明。其他的Alpha值类似。&lt;/p&gt;
&lt;p&gt;当我们有多张图片需要层叠的时候，并且每一层都有一个Alpha值的时候，我们需要怎么计算呢？&lt;/p&gt;
&lt;p&gt;从我们的直观上可以想象出来，当我们在看一堆颜色混合而成的颜色的时候，首先是离我们最近的pic1作为前景，其后面的pic2-picn糊混合结果作为背景，混合出来的结果。而pic2-picn是如何混合的呢？它是由pic2作为前景，pic3-picn混合结果作为背景混合出来的结果。如此递归下去知道最后两张图片混合完成。&lt;/p&gt;
&lt;p&gt;好了，到这里我们应该很了解在OpenGL中颜色混合的原理了。接下来动手试试。&lt;/p&gt;
&lt;p&gt;首先需要修改LoadGLTextures方法中的文件名，因为本次实验使用的是一张新的位图。将&lt;code&gt;&amp;quot;Data/Crate.bmp&amp;quot;&lt;/code&gt;改成&lt;code&gt;&amp;quot;Data/glass.bmp&amp;quot;&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;然后我们需要修改InitGL方法。在使用glEnable(GL_LIGHT1);激活光源之后，我们添加新的两行glColor4f和glBlendFunc方法。&lt;/p&gt;
&lt;p&gt;不过需要注意的是，在使用glColor4f以全亮度进行绘制的时候，它会和光照系统glLightfv产生的效果互相排斥。具体的排斥方式请参看&lt;a href="http://blog.csdn.net/tmljs1988/article/details/6445100"&gt;【 opengl纹理,光照,glColor4f(),混合】&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;另外在glBlendFunc中，为什么会取GL_SRC_ALPHA,GL_ONE，以及GL_SRC_ALPHA,GL_ONE这两个参数会对最终的效果产生什么影响。我们可以参考&lt;a href="http://blog.csdn.net/aurora_mylove/article/details/1700540"&gt;【 颜色混合opengl】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后，我们修改WinMain就能够结束本次实验。接着上一次实验的代码.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;1&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VK_LEFT&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="c1"&gt;// Left方向键按下了么?
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;2&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;3&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;yspeed&lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="mf"&gt;0.01f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 若是, 减少yspeed
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;4&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们增加如下的代码。这几行监视B键是否按下。如果是的话，计算机检查混合选项是否已经打开。然后将其置为相反的状态。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 1&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// Blending Code Starts Here
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 2&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 3&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 4&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;bp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 5&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;blend&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;blend&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 6&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;blend&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 7&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 8&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glEnable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL_BLEND&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Turn Blending On
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 9&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glDisable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL_DEPTH_TEST&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Turn Depth Testing Off
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;10&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;11&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;12&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;13&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glDisable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL_BLEND&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Turn Blending Off
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;14&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glEnable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL_DEPTH_TEST&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Turn Depth Testing On
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;15&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;16&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;17&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;18&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;19&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;bp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;20&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;21&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// Blending Code Ends Here
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;到这里本次课程就结束了，我们试着按下B键查看透视效果怎样，另外我们还可以看看当前代码下，打开光源和不打开光源下，按下B键查看透视效果会有什么区别。思考为什么（光源和glColor4f的冲突）。&lt;/p&gt;</description></item><item><title>OpenGL学习笔记（五）</title><link>https://yaoyl.cn/post/%E5%8E%86%E5%8F%B2/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</link><pubDate>Sun, 07 May 2017 12:21:47 +0000</pubDate><guid>https://yaoyl.cn/post/%E5%8E%86%E5%8F%B2/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</guid><description>
&lt;p&gt;&lt;strong&gt;龙云尧个人博客，转载请注明出处。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CSDN地址：http://blog.csdn.net/michael753951/article/details/71316132&lt;/p&gt;
&lt;p&gt;个人blog地址：http://yaoyl.cn/nehexue-xi-bi-ji-wu/&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这次我们将尝试Lesson6和Lesson7的内容。这个部分我们将学习怎么给一个模型进行纹理映射（其实就是贴图）。&lt;/p&gt;
&lt;h2 id="环境搭建"&gt;环境搭建&lt;/h2&gt;
&lt;p&gt;这次实验因为需要使用OpenGL的glaux.h库头使用位图对构建的图形进行纹理映射。所以我们需要进一步进行环境搭建。（注：环境搭建很麻烦，因为微软的VS环境很乱）&lt;/p&gt;
&lt;p&gt;如何布置这个库头可以参考&lt;a href="http://blog.csdn.net/delphiwcdj/article/details/6326586/"&gt;【 VS2008无法打开gl/glaux.h头文件的解决方法】&lt;/a&gt;我使用的是方法4，测试能够正确include库头。&lt;/p&gt;
&lt;p&gt;在高版本的VS中，因为VS使用的是自己重新修改过的C++，所以在进行编译的过程中，可能会出现ERROR LNK2019报错，无法解析“_sscanf,_sscanf_s”，这个时候我们可以参考&lt;a href="http://blog.csdn.net/u010317005/article/details/51155363"&gt;【 VS2015 无法解析的外部符号 __vsnwprintf_s】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果我们在使用AUX_RGBImageRec定义变量的时候，系统没有报错的话，就说明我们本次基本的环境已经搭建好了。&lt;/p&gt;
&lt;p&gt;另外，因为我们在实验中需要使用fopen，而微软的VS2015中会强行报错，为了避免不必要的麻烦，我们需要关掉fopen的报错。这个部分我们可以参考&lt;a href="http://jingyan.baidu.com/article/ce436649fd61543773afd32e.html"&gt;【百度经验：VS2013中如何解决error C4996: 'fopen'问题】&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="开始实现"&gt;开始实现&lt;/h2&gt;
&lt;p&gt;如果没出什么问题的话，到这里我们应该能够正常的编写这一刻的代码了。（如果还有什么报错请尝试自行解决或者戳我）。&lt;/p&gt;
&lt;p&gt;本次需要在3维图像上添加纹理映射，首先需要的是读取位图像文件。读取的代码如下。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 1&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;AUX_RGBImageRec&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;LoadBMP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;Filename&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Loads A Bitmap Image
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 2&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 3&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;File&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// File Handle
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 4&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 5&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;Filename&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Make Sure A Filename Was Given
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 6&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 7&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// If Not Return NULL
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 8&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 9&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;10&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;File&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nf"&gt;fopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;r&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Check To See If The File Exists
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;11&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;12&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;File&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Does The File Exist?
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;13&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;14&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;fclose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;File&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Close The Handle
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;15&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nf"&gt;auxDIBImageLoad&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Filename&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Load The Bitmap And Return A Pointer
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;16&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;17&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;18&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// If Load Failed Return NULL
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;19&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;20&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;21&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;LoadGLTextures&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;// Load Bitmaps And Convert To Textures
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;22&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;23&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Status&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Status Indicator
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;24&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;25&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;AUX_RGBImageRec&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;TextureImage&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// Create Storage Space For The Texture
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;26&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;27&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TextureImage&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Set The Pointer To NULL
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;28&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;29&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// Load The Bitmap, Check For Errors, If Bitmap&amp;#39;s Not Found Quit
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;30&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TextureImage&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nf"&gt;LoadBMP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;Data/NeHe.bmp&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;31&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;32&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Status&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Set The Status To TRUE
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;33&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;34&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glGenTextures&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;texture&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt; &lt;span class="c1"&gt;// Create The Texture
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;35&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;36&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// Typical Texture Generation Using Data From The Bitmap
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;37&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glBindTexture&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL_TEXTURE_2D&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;texture&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;38&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glTexImage2D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL_TEXTURE_2D&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TextureImage&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sizeX&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TextureImage&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sizeY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;GL_RGB&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;GL_UNSIGNED_BYTE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TextureImage&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;39&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glTexParameteri&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL_TEXTURE_2D&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;GL_TEXTURE_MIN_FILTER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;GL_LINEAR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;40&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glTexParameteri&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL_TEXTURE_2D&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;GL_TEXTURE_MAG_FILTER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;GL_LINEAR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;41&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;42&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;43&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TextureImage&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="c1"&gt;// If Texture Exists
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;44&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;45&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TextureImage&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// If Texture Image Exists
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;46&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;47&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TextureImage&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Free The Texture Image Memory
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;48&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;49&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;50&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TextureImage&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt; &lt;span class="c1"&gt;// Free The Image Structure
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;51&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;52&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;53&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Status&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Return The Status
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;54&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一个函数LoadBMP不需要解释，主要功能就是探寻目的位置中是否存在该图像文件。如果存在就调用auxDIBImageLoad将位图加载成渲染文件返回出来。&lt;/p&gt;</description></item><item><title>OpenGL学习笔记（四）</title><link>https://yaoyl.cn/post/%E5%8E%86%E5%8F%B2/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</link><pubDate>Sun, 07 May 2017 12:20:57 +0000</pubDate><guid>https://yaoyl.cn/post/%E5%8E%86%E5%8F%B2/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</guid><description>
&lt;p&gt;&lt;strong&gt;龙云尧个人博客，转载请注明出处。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CSDN地址：http://blog.csdn.net/michael753951/article/details/71316089&lt;/p&gt;
&lt;p&gt;个人blog地址：http://yaoyl.cn/nehexue-xi-bi-ji-si/&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="图像旋转"&gt;图像旋转&lt;/h2&gt;
&lt;p&gt;接下来我们将学习图像旋转。图像的旋转通过调用glRotatef(Angle,Xvector,Yvector,Zvector)实现。Angle表示旋转角度（注意是角度不是弧度），Xvector表示沿X轴旋转，Yvector表示沿着Y轴旋转，Zvector表示沿着Z轴旋转。注意旋转角度和RGB设置不一样，RGB的范围是0.0f-1.0f，而角度旋转的范围是0.0f-360.0f(其实可以超过360.0f，不过为了避免溢出我们应该将其做一个约束)。&lt;/p&gt;
&lt;p&gt;图像的旋转方向遵循右手定则，即右手握住旋转的轴，右手大拇指朝向轴的正方向，那么你右手其他手指所朝的方向便为正方向。&lt;/p&gt;
&lt;p&gt;为了实现图像的旋转，我们将尝试调用一个glRotatef方法。&lt;/p&gt;
&lt;p&gt;首先我们还是在DrawGLScene方法中，通过glTranslatef确定绘点以后，我们就可以插入glRotatef(rtri, 0.0f, 0.0f, 1.0f)来绕着Z轴旋转。为此我们需要定义一个GLfloat类型的全局变量rtri。同时在DrawGLScene方法结束之前我们需要不断改变rtri的值来实现图像的旋转工作。&lt;/p&gt;
&lt;p&gt;最终的参考代码如下（注意需要自己定义一个全局变量rtri）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 1&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;DrawGLScene&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GLvoid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// 从这里开始进行所有的绘制
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 2&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 3&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glClear&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL_COLOR_BUFFER_BIT&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;GL_DEPTH_BUFFER_BIT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 清除屏幕和深度缓存
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 4&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glLoadIdentity&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// 重置当前的模型观察矩阵
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 5&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;//当您调用glLoadIdentity()之后，您实际上将当前点移到了屏幕中心，X坐标轴从左至右，Y坐标轴从下至上，Z坐标轴从里至外。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 6&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;//中心左面的坐标值是负值，右面是正值。移向屏幕顶端是正值，移向屏幕底端是负值。移入屏幕深处是负值，移出屏幕则是正值。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 7&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 8&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;//glTranslatef(x, y, z)沿着 X, Y 和 Z 轴移动。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 9&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;//根据前面的次序，下面的代码沿着X轴左移1.5个单位，Y轴不动(0.0f)，最后移入屏幕6.0f个单位。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;10&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;//注意在glTranslatef(x, y, z)中当您移动的时候，您并不是相对屏幕中心移动，而是相对与当前所在的屏幕位置。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;11&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glTranslatef&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.5f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;6.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 左移 1.5 单位，并移入屏幕 6.0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;12&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glRotatef&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rtri&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Rotate The Triangle On The Y axis ( NEW )
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;13&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;//glBegin(GL_TRIANGLES)的意思是开始绘制三角形，glEnd() 告诉OpenGL三角形已经创建好了。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;14&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;//本节的简单示例中，我们只画一个三角形。如果要画第二个三角形的话，可以在这三点之后，再加三行代码(3点)。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;15&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glBegin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL_TRIANGLES&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Drawing Using Triangles
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;16&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;//接下来的一行代码设置三角形的第一个顶点(三角形的上顶点)，并使用当前颜色(红色)来绘制。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;17&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glColor3f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 设置当前色为红色
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;18&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glVertex3f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Top
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;19&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glColor3f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 设置当前色为绿色
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;20&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glVertex3f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Bottom Left
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;21&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glColor3f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 设置当前色为蓝色
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;22&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glVertex3f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Bottom Right
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;23&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glEnd&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// Finished Drawing The Triangle
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;24&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;//在屏幕的左半部分画完三角形后，我们要移到右半部分来画正方形。为此要再次使用glTranslate。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;25&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glTranslatef&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;3.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Move Right 3 Units
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;26&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;//现在使用GL_QUADS绘制正方形。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;27&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glBegin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL_QUADS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Draw A Quad
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;28&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;//glColor3f(1.0f, 0.0f, 0.0f); // 将当前色设置为蓝色
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;29&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glVertex3f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Top Left
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;30&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glVertex3f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Top Right
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;31&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;//glColor3f(0.0f, 0.1f, 0.0f); // 将当前色设置为蓝色
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;32&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glVertex3f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Bottom Right
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;33&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glVertex3f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Bottom Left
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;34&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glEnd&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// Done Drawing The Quad
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;35&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;rtri&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mf"&gt;0.2f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Increase The Rotation Variable For The Triangle ( NEW )
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;36&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Everything Went OK
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;37&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;实现的效果如下图所示。&lt;/p&gt;</description></item><item><title>OpenGL学习笔记（三）</title><link>https://yaoyl.cn/post/%E5%8E%86%E5%8F%B2/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</link><pubDate>Wed, 03 May 2017 15:14:09 +0000</pubDate><guid>https://yaoyl.cn/post/%E5%8E%86%E5%8F%B2/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</guid><description>
&lt;p&gt;第二课和第三课内容为三角形和矩形的颜色渲染内容，通过实例告诉我们如何给实现的样例进行上色。&lt;/p&gt;
&lt;p&gt;我们已经知道任何在OpenGL中，任何形状都将最终被分解成矩形和三角形两种形状，所以在这两课中我们将对三角形和矩形的构建和渲染进行学习。&lt;/p&gt;
&lt;h2 id="三角形和矩形构造"&gt;三角形和矩形构造&lt;/h2&gt;
&lt;p&gt;构建三角形或者矩形的方法在DrawGLScene方法中实现。&lt;/p&gt;
&lt;p&gt;绘制图像之前我们需要先将屏幕缓存清理掉，即调用glClear和glLoadIdentity。这个时候屏幕上的定位点将被重置于窗口的正中间。&lt;/p&gt;
&lt;p&gt;整个屏幕按照空间直角坐标系的形式进行坐标划分，分为X轴，Y轴和Z轴，其中&lt;strong&gt;X轴正方向为右方，Y轴正方向为上方，Z轴正方向为屏幕外侧，原点为你的窗口中央。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开始绘制图形的之前，我们首先需要使用glTranslatef对绘制的点进行偏移，将其移到适当的位置之后开始进行图像绘制（记住绘制点初始值位于屏幕正中央。）&lt;/p&gt;
&lt;p&gt;绘制图形之前，我们需要调用glBegin(GL_TRIANGLES)来决定绘制图形。GL_TRIANGLES表示绘制一个三角形，GL_QUADS表示绘制一个矩形。如果需要绘制更多点组成的图形的话，可以使用GL_POLYGON。&lt;/p&gt;
&lt;p&gt;下面以三角形的绘制为例，通过调用glVertex3f方法设置三个顶点的坐标我们就可以画出一个简单的三角形。如果需要绘制多个三角形，可以在glBegin之后添加3*n行glVertex3f方法，就能绘制出n个三角形。&lt;/p&gt;
&lt;p&gt;绘制结束之后，我们将调用glEnd();表示本次绘制结束。&lt;/p&gt;
&lt;p&gt;下面将展示第二课的代码及其实现效果。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 1&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;DrawGLScene&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GLvoid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Here&amp;#39;s Where We Do All The Drawing
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 2&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 3&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glClear&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL_COLOR_BUFFER_BIT&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;GL_DEPTH_BUFFER_BIT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Clear Screen And Depth Buffer
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 4&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glLoadIdentity&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// Reset The Current Modelview Matrix
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 5&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glTranslatef&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.5f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;6.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Move Left 1.5 Units And Into The Screen 6.0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 6&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glBegin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL_TRIANGLES&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Drawing Using Triangles
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 7&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glVertex3f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Top
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 8&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glVertex3f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Bottom Left
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 9&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glVertex3f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Bottom Right
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;10&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glEnd&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// Finished Drawing The Triangle
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;11&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glTranslatef&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;3.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Move Right 3 Units
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;12&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glBegin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL_QUADS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Draw A Quad
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;13&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glVertex3f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Top Left
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;14&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glVertex3f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Top Right
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;15&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glVertex3f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Bottom Right
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;16&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glVertex3f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Bottom Left
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;17&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;glEnd&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// Done Drawing The Quad
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;18&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Keep Going
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;19&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;绘制出来的效果图如下所示。
&lt;figure&gt;
&lt;picture&gt;
&lt;img
loading="lazy"
decoding="async"
alt=""
class="image_figure image_internal image_unprocessed"
src="https://yaoyl.cn/"
/&gt;
&lt;/picture&gt;
&lt;/figure&gt;
&lt;/p&gt;</description></item><item><title>OpenGL学习笔记（一）</title><link>https://yaoyl.cn/post/%E5%8E%86%E5%8F%B2/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</link><pubDate>Mon, 01 May 2017 10:08:09 +0000</pubDate><guid>https://yaoyl.cn/post/%E5%8E%86%E5%8F%B2/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</guid><description>
&lt;p&gt;龙云尧个人博客，转载请注明出处。&lt;/p&gt;
&lt;p&gt;CSDN地址：http://blog.csdn.net/michael753951/article/details/70254340&lt;/p&gt;
&lt;p&gt;个人blog地址：http://123.207.243.115:81/rfidshi-yan-yi-zong-jie-2/&lt;/p&gt;
&lt;p&gt;因为实验需要，我要使用OpenGL搭建一个仿真驾驶环境。因为之前没有接触过OpenGL的相关知识，淦哥推荐通过NEHE来进行学习，之后会零零散散做一些笔记用来进行记录。学习的博客参见&lt;a href="http://blog.51cto.com/zt/186/1"&gt;【地址】&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="创建新的c"&gt;创建新的C++&lt;/h2&gt;
&lt;p&gt;因为实验需要，我需要使用C++进行整个项目的编写。实验之前，我们需要先知道怎么用VS搭建一个窗口程序，这里我参考了&lt;a href="http://blog.csdn.net/yongh701/article/details/54896321"&gt;【这篇博客】&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;需要注意的是，在实验中，不推荐直接按照博客中使用L对字符串直接进行强制转换的方式，这种方法在之后学习NEHE过程中会出现很多不可避免的问题。同时这种方式在输出中文的时候也会出翔错误，这个不是我们想看到的。所以我们还需要进行相关的设置。&lt;/p&gt;
&lt;p&gt;设置方法这里我们参考&lt;a href="http://blog.csdn.net/ccf19881030/article/details/7967514"&gt;【这篇博客】&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;设置完成以后，我们就能很正常的输出字符串了，也不再需要在字符串前面加上L进行强制转换，之后进行NEHE学习的时候也能更加简单。&lt;/p&gt;
&lt;h2 id="实验环境搭建"&gt;实验环境搭建&lt;/h2&gt;
&lt;p&gt;我在实验开发中使用的是VS2015专业版进行开发。需要使用到的所有库文件和环境搭建可以参考&lt;a href="http://www.cnblogs.com/zpcdbky/p/6724772.html"&gt;【这里】&lt;/a&gt;，环境搭建完成之后，尝试include某些库头，如果没有报错，那就说明环境搭建成功。&lt;/p&gt;
&lt;h2 id="可能出现的问题"&gt;可能出现的问题&lt;/h2&gt;
&lt;p&gt;实验过程中，最好从教程中，一个函数一个函数向你的项目中添加，如果一次性添加太多的话，报错太多可能会让你很崩溃。&lt;/p&gt;
&lt;p&gt;在添加函数的过程中，在开始调用PDB文件之后，可能会出现很多的“无法查找或打开PDB文件”错误信息，为了解决这个问题，你可以参考&lt;a href="http://blog.163.com/qimo601@126/blog/static/1582209320143410125543/"&gt;【这篇博客】&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果在环境搭建过程中还出现了其他问题，试着参照&lt;a href="http://www.cnblogs.com/clairvoyant/p/5453551.html"&gt;【这篇博客】&lt;/a&gt;进行解决。&lt;/p&gt;
&lt;h2 id="逻辑图"&gt;逻辑图&lt;/h2&gt;
&lt;p&gt;经过仔细阅读源码以及理解，整个NEHE第一课的代码框架结构如下。&lt;/p&gt;
&lt;p&gt;理解过程中，我们其他的目前可以不用很掌握，但是一定要清楚，在本次项目中，作者将**OpenGL的着色描述表定义为 hRC &lt;strong&gt;。要让您的程序能够绘制窗口的话，还需要创建一个设备描述表&lt;/strong&gt;。Windows的设备描述表被定义为 hDC **。&lt;strong&gt;DC将窗口连接到GDI&lt;/strong&gt;(Graphics Device Interface图形设备接口)。&lt;strong&gt;而RC将OpenGL连接到DC&lt;/strong&gt;。&lt;strong&gt;变量 hWnd 将保存由Windows给我们的窗口指派的句柄&lt;/strong&gt;。最后，&lt;strong&gt;程序的实例保存在hInstance中(实例)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;通过上面的关系，我们能够更加容易的理解窗口的建立与注销的过程中，作者代码中每一步所做的目的和意义。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
&lt;picture&gt;
&lt;img
loading="lazy"
decoding="async"
alt=""
class="image_figure image_internal image_unprocessed"
src="https://yaoyl.cn/"
/&gt;
&lt;/picture&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id="实验结果"&gt;实验结果&lt;/h2&gt;
&lt;p&gt;在读完代码之后，我们知道本次实验中仅仅只是建立一个640*480的窗口。并没有任何内容显示，另外因为我们在初始化设置中(InitGL这个方法中定义的)将屏幕的初始RGB值设置为（0.0f, 0.0f, 0.0f, 0.5f），所以程序运行的结果如图所示。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
&lt;picture&gt;
&lt;img
loading="lazy"
decoding="async"
alt="实验一截图"
class="image_figure image_internal image_unprocessed"
src="https://yaoyl.cn/"
/&gt;
&lt;/picture&gt;
&lt;/figure&gt;
&lt;/p&gt;</description></item></channel></rss>